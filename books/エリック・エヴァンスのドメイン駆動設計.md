# エリック・エヴァンスのドメイン駆動設計

## パターン一覧

### 第1部 ドメインモデルを機能させる

- ユビキタス言語
- モデル駆動設計
- 実践的モデラ

### 第2部 モデル駆動設計の構成要素

- レイヤ化アーキテクチャ
- 利口なUI（アンチパターン）
- エンティティ
- 値オブジェクト
- サービス
- モジュール
- 集約
- ファクトリ
- リポジトリ

### 第3部 より深い洞察へ向かうリファクタリング

- 仕様
- 意図の明白なインタフェース
- 副作用のない関数
- 表明
- 概念の輪郭
- 独立したクラス
- 閉じた操作

### 第4部 戦略的設計

- 境界づけられたコンテキスト
- 継続的な統合
- コンテキストマップ
- 共有カーネル
- 顧客/供給者の開発チーム
- 順応者
- 腐敗防止層
- 別々の道
- 公開ホストサービス
- 公表された言語
- コアドメイン
- 汎用サブドメイン
- ドメインビジョン声明文
- 強調されたコア
- 凝縮されたメカニズム
- 隔離されたコア
- 抽象化されたコア
- 進化する秩序
- システムのメタファ
- 責務のレイヤ
- 知識レベル
- 着脱可能コンポーネントのフレームワーク

## ドメイン駆動設計とは

ドメインとはビジネスであり、アプリケーションが対象とする業務領域のことである。
また、モデルとはある対象について関連する側面を抽象化した、現実に対する1つの解釈のことである。

ドメイン駆動設計（DDD）とは、ドメインモデルをソフトウェア開発の中心に置き、コードやコミュニケーションを常にドメインモデルと一体化させながら、ドメインモデルを反復的に深化させることでより価値の高いアプリケーションを生み出そうとする考え方である。

### DDDの原則

DDDを駆動している原則は次の3つである：

- コアドメインに集中すること
- ドメインの実践者とソフトウェアの実践者による創造的な共同作業を通じて、モデルを探求すること
- 明示的な境界づけられたコンテキストの内部で、ユビキタス言語を語ること

## 第1部 ドメインモデルを機能させる

まず、DDDが目指す最終的な目標を明確にする。
ドメインモデルが機能し、開発プロジェクトを駆動するエンジンになるとはどういうことなのかを、3つのパターンによって示す。

### 1. ユビキタス言語

ビジネスドメインを正しく捉えた、柔軟で価値の高いソフトウェアを設計するには、チームの共通言語をつくらなければならない。
それゆえ、モデルを言語の骨格として使用し、チーム内のすべてのコミュニケーションとコードにおいて、その言語を厳格に用いること。

### 2. モデル駆動設計

ユビキタス言語を実現するには、コードにおいてもドメインモデルが正確に表現されていないければならない。
それゆえ、ドメインモデルとコードが常にお互いを反映するように保つこと。
こうすることで、ドメインモデルの変更がそのままコードを修正し、またコードの中で得られた新たなドメイン知識がドメインモデルに反映されるようになる。

### 3. 実践的モデラ

もしモデラがプログラムを書けなかったり、プログラマがドメインモデルに興味を持たなかったら、MDDの利点である好循環は生まれない。
それゆえ、MDDをとおしてユビキタス言語を実現するために、チームのすべての開発者が、プログラムを書くモデラであること。

## 第2部 モデル駆動設計の構成要素

ここでは、DDDの要であるMDDを実現するための基礎を示す。

### 4. レイヤ化アーキテクチャ

ドメインモデルとコードとを結びつけるMDDを実践するには、ビジネスロジックが他のコードから切り離されていなければならない。
それゆえ、ソフトウェアを以下の4層に分けること。
各レイヤを下位層だけに依存するようにすることで、ドメイン層はドメインモデルを表現するという責務に専念できる。

- **ユーザインタフェース層**
  - ユーザに情報を表示して、ユーザからの入力を解釈する責務を負う
- **アプリケーション層**
  - ドメインオブジェクトを操作することで、ソフトウェアが果たすべきことを実現する責務を負う
- **ドメイン層**
  - ビジネスの概念、置かれた状況に関する情報、ルールなどを表す責務を負う
- **インフラストラクチャ層**
  - 上位のレイヤを支える一般的な技術的機能を提供する責務を負う

### 5. 利口なUI（アンチパターン）

洗練されていないチームが、単純なプロジェクトを担当するに当たって、レイヤ化アーキテクチャを伴うモデル駆動設計に挑戦しようとすると、習得の難しさに苦労することになる。
それゆえ、状況が許せばすべてのビジネスロジックをユーザインタフェースに入れること。
単純なアプリケーションなどに適しているが、このパターンを採用するとMDDは一切機能しなくなる。
レイヤ化アーキテクチャの対をなすパターン。

ドメインモデルの構成要素は、大きく「エンティティ」「値オブジェクト」「サービス」の3つに分類できる。
ドメインモデリングの際は、そのモデルがどの要素であるかを定義し、それぞれを切り離して設計しなければならない。

- **6. エンティティ**
  - 同一性によって識別されるオブジェクト
- **7. 値オブジェクト**
  - その属性しか関心の対象とならないオブジェクト
- **8. サービス**
  - ドメインにおける重要なプロセスで、エンティティや値オブジェクトの自然な責務ではないもの。
    基本的に状態を持たない

### 9. モジュール

人間が一度に考えられる物事の量には限界がある。
それゆえ、ドメインモデルの概念やコードが肥大化した場合、モジュールによる分割を検討すること。
モジュールは高凝集/低結合になるよう設計し、またユビキタス言語の一部になる名前をつけること。

オブジェクトには、生成から消滅までのライフサイクルがある。
一時的にデータベース上に保存されたりもする。
こうしたライフサイクルも、ドメインの設計に組入れなければならない。

### 10. 集約

複雑な関連を伴うモデルでは、オブジェクトに対する変更の一貫性を保証するのは難しい。
それゆえ、エンティティと値オブジェクトを集約の中にまとめ、各集約の周囲に境界を定義すること。
また、各集約に対してルートとなるエンティティを1つ選び、境界の内部に存在するオブジェクトへのアクセスは、そのルートを経由して制御すること。

### 11. ファクトリ

複雑なオブジェクトの生成はドメイン層の責務であるが、その仕事はモデルを表現するオブジェクトのものではない。
そういう責務を組み合わせてしまうと、理解しにくく不格好な設計が作り出されてしまう。
それゆえ、複雑なオブジェクトと集約のインスタンスを生成する責務を、別のオブジェクトに移すこと。

### 12. リポジトリ

集約ルート以外のオブジェクトがデータベースクエリを自由に行なうと、集約のカプセル化に違反しかねない。
それゆえ、永続化/問い合わせ専用のオブジェクトを導入し、ドメインモデルがあたかもメモリ上にコレクションとして存在していると錯覚させること。
また、集約ルートに対してのみ、これを提供すること。

## 第3部 より深い洞察へ向かうリファクタリング

ドメインモデリングにおいては、ドメインエキスパートの知識をよりよく反映した「深いモデル」と、絶え間ないドメインリファクタリングを可能にする「しなやかな設計」が重要である。

「深いモデル」を得るには、ドメインに隠された概念（=仕様）を見つけ出す必要がある。

### 13. 仕様

ビジネスルールは、エンティティや値オブジェクトの責務のどれとも合致しないことがある。
しかし、ドメイン層から取り出してしまうと、モデルを表現しなくなってしまう。
それゆえ、あるオブジェクトが何らかの基準を満たしているかどうかを判定する述語的な値オブジェクトを明示的に作成すること。

仕様は、以下のうち1つでも当てはまれば導入する必要がある：

- オブジェクトの妥当性を検証する
- コレクションからオブジェクトを選択する
- 要求に適合する新しいオブジェクトの生成を定義する

「しなやかな設計」は「深いモデル」を補完するものであり、その要点は抽象化と分割の2つである。

抽象化において重要なことは、モデルを見ただけでその振る舞いが容易に理解できるようにし、カプセル化の価値を最大限に高めることである。

### 14. 意図の明白なインタフェース

開発者があるコンポーネントを使用するために、その実装についてじっくり考えなければならないのであれば、カプセル化の価値は失われる。
それゆえ、クラスと操作には、その効果と目的を記述する名前をつけ、これを実行する手段には言及しないこと。
こうした名前はユビキタス言語に従っていなければならない。

### 15. 副作用のない関数

副作用のある（オブジェクトの状態が変化する）メソッドを組み合わせてしまうと、プログラムの振る舞いを理解することが極端に難しくなる。
それゆえ、プログラムロジックのうち、できる限り多くの部分を関数（目に見える副作用なしに結果を戻す操作）に置くこと。

### 16. 表明

副作用の無い関数を用いても、副作用のある操作は必ずどこかで必要になる。
操作の副作用が実装によって暗黙的にしか定義されていない場合、委譲が多く行なわれている設計では、原因と結果がもつれてしまう。
それゆえ、操作の事後条件と、クラスおよび集約の不変条件をドキュメンテーションなどに宣言すること。

分割において重要なことは、適切な粒度の選択と、依存関係を極力排除することであり、その結果変更のコストを低減することができる。

### 17. 概念の輪郭

モデルや設計の要素が一枚岩の構造に埋め込まれていると、機能は重複する。
その一方で、クラスやメソッドを分割すると、クライアントを無意味に複雑にしてしまうかもしれない。
ドメインにはいくつもの概念が隠されていて、それら凝集度の高い概念群の間には見えない境界線（輪郭）が存在する。
それゆえ、モデルのリファクタリングを繰り返すことでこれを見つけ出し、オブジェクトの粒度がその輪郭に沿うようにすること。

### 18. 独立したクラス

1つのモジュールの中であっても、設計を解釈することは、依存関係が加わるにつれて無秩序に難しくなる。
それゆえ、オブジェクトは低結合で設計すること。
オブジェクトのイメージの中から他の概念をすべて取り除くこと。

### 19. 閉じた操作

操作の引数や戻り値に新しいクラスが登場すると、それは新たな依存関係の導入になる。
それゆえ、戻り値の方が引数の型と同じにできる場合は、そのように操作を定義すること。

## 第4部 戦略的設計

大規模プロジェクトであっても、ドメイン駆動設計が実装と結びつかないモデルを作り出すことはない。
このことは、以下の3つの方法により実現する。

- **コンテキスト**
  - 他システムとの統合を、ドメインモデルの一貫性を保ちながら実現する方法
- **蒸留**
  - ドメインにおいて最も重要な本質部分を抽出し、そこに注力するための方法
- **大規模な構造**
  - アーキテクチャレベルの「大きな絵」を、チーム内/チーム間で共有するための方法

大規模プロジェクトでは、異なるドメインモデル間の不整合が大きな問題となる。
たとえば、顧客に対する請求のシステムとビジネスパートナーへの支払いを管理するシステムとでは、同じ「請求」というユビキタス言語でも意味するところは異なる。
DDDでは、ドメインモデルの有効範囲となる「コンテキスト」を考える。

### 20. 境界づけられたコンテキスト

複数のモデルはどんな巨大なプロジェクトにも存在する。
ドメインモデルが異なるものを無理やり1つのコードで表そうとすると無理が生じ、またチーム内でのコミュニケーションも破綻する。
それゆえ、モデルが適用されるコンテキストを明示的に定義すること。
その境界内では、モデルを厳密に一貫性のあるものに保ち、境界の外部の問題によって注意を逸らされたりするのを避けること。

### 21. 継続的な統合

多くの人々が同一の境界づけられたコンテキストで作業していると、モデルが分裂する傾向は強くなる。
それゆえ、すべてのコードと他の実装成果物を頻繁にマージさせるプロセスを策定すること。
その際、分裂に対して素早く警告する自動化されたテストも一緒に用いること。

### 22. コンテキストマップ

他のチームに所属する人々は、コンテキストの境界をあまり意識せず、境目をぼかしたり相互の接続を複雑にしたりする変更を、そうとは知らずに加えるかもしれない。
それゆえ、プロジェクトで機能しているモデルをそれぞれ識別して、その境界づけられたコンテキストを定義すること。
境界づけられたコンテキストそれぞれに名前をつけ、その名前をユビキタス言語の一部にすること。

コンテキストマップにおけるコンテキスト間の関係は、次の6種類がある。

### 23. 共有カーネル

互いに関連しあう複数のコンテキストを別々のチームで開発しているときに、わざわざモデルの変換層を用意しコンテキストの自立性を保つよりも、モデルの一部を共有してしまう方が現実的な場合もある。
それゆえ、チーム間が共有することに合意したドメインモデルのサブセットを指定すること。
これにはモデルやコード、データベース設計も含まれる。
また、稼働しているシステムは頻繁に結合すること。

### 24. 顧客/供給者の開発チーム

コンテキストマップの分かれた2つのシステム間において、一方が変更に対する拒否権を持っている場合や、変更を要求するための手続きがあまりに面倒な場合がある。
それゆえ、2つのチームの間に明確な顧客/供給者という関係を確立すること。
供給者は顧客に対して、実際に交渉や見積もりを行なうこと。
また、受け入れテストを供給者の継続的な統合に組み入れること。

### 25. 順応者

供給者が力を持っている場合など、主に政治的な理由で顧客/供給者の関係が構築できないこともある。
そのときはコンテキストマップを固持せずに、あえて供給者のドメインモデルに隷属的に従うことを検討すること。

### 26. 腐敗防止層

新しいシステムを構築していて、それが他のシステムと接する巨大なインタフェースを持たなければならない場合、2つのモデルを関係づけることが難しいときがある。
このとき、新しいシステムと既存システムとの間に隔離するためのレイヤを作成することによって、クライアントに対して、独自のドメインモデルの用語で表現された機能を提供すること。

### 27. 別々の道

統合は常に高くつくが、それによる利益は小さいこともある。
それゆえ、統合するメリットがなければ、互いに無関係なコンテキストマップとして実装すること。

### 28. 公開ホストサービス

あるサブシステムをその他多くのサブシステムと統合しなければならない場合、それぞれに対して特別に変換サービスを作成すると、コストが膨れ上がってしまい、また変更の際に注意すべきことも次々と増える。
それゆえ、サブシステムにアクセスできるようにするプロトコルを、共有サービスの形で定義すること。
新しい統合の要件に対応する際には、プロトコルに機能を追加し、拡張すること。

コンテキスト間の関係を構築する際に、次のような補足的なパターンを用いることもできる。

### 29. 公表された言語

既存のドメインへの/からの直接的な変換は、適切な解決策ではないことがある。
それゆえ、必要なドメインの情報をコミュニケーションにおける共通の媒体として表現できる、明確にドキュメント化された共有言語を使用し、必要に応じてその言語への/からの変換を行なうこと（たとえばXMLなど）。

コンテキストによって一貫性のあるドメインモデルを維持できたとしても、複数ドメインが関与する複雑なプロジェクトからビジネスに重要な本質部分を見抜くことは難しい。
DDDでは、7つのパターンによって、複雑なシステムから本質部分を「蒸留」する方法を示す。
蒸留は、開発上の優先度を示すとともに、アウトソースやオフショア開発、パッケージ製品の導入など、戦略上の決定をする際の指針にもなる。

ビジネスの本質部分を見つけるには、ドメインを「コアドメイン」と「汎用サブドメイン」の2つに分類する。

### 30. コアドメイン

巨大なシステムを設計する際には、寄与するコンポーネントの数が非常に多い。
しかも、どれも複雑な上に成功にはすべてが絶対に必要である。
それゆえ、ビジネスにとって最も影響力のある重要なドメイン（コアドメイン）を見つけて、それをサポートする大量のモデルやコードから容易に区別する手段を提供すること。
コアドメインの資産価値を最大化しつつ、他のドメインはコアドメインへの貢献度によりその投資対効果を評価すること。

### 31. 汎用サブドメイン

モデルの中には、ビジネス上の差別化要因とならない汎用的な機能を提供するだけのもの（サブドメイン）がある。
そうしたサブドメインから汎用的なモデルを括り出して、別のモジュールに入れること。
一度分離したら、その部分に対して継続される開発の優先順位をコアドメインより下げること。

汎用サブドメインの構築には、以下の4つの選択肢がある：
1. パッケージ製品を導入する
2. 公表されたモデルを利用する
3. 開発をアウトソースする
4. 自社で開発する

コアドメインを見つけたら、これを見失わないように文書化する。

### 32. ドメインビジョン声明文

開発においては、モデルを詳細に調べなくても分かる形で、システムの価値を説明する必要がある。
それゆえ、コアドメインとそれがもたらす価値に関する簡潔な記述を作成すること（約1ページ）。
この文書は早期に作成し、新しい洞察を得たら改定すること。

### 33. 強調されたコア

具体的なコアモデルの要素の識別は、予測できない個人の解釈に委ねられてしまい、ドメインビジョン声明文だけでは効果がない。
それゆえ、簡潔なドキュメント（3〜7ページ程度）を書き、コアドメインとコアを構成する要素間の主要な相互作用を記述すること。
また、プロジェクトのモデル全体を記述した正式なドキュメント上で、コアドメインの構成要素となるモデルに印をつけること。

コアドメインは、そのままでは本質と関係のない不純物が混ざっていたり、複雑すぎることがある。
ドメインリファクタリングによって、コアドメインをより見えやすく扱いやすいものに変更する必要がある。

### 34. 凝縮されたメカニズム

処理が設計を肥大させる理由として、概念的な「なにが」が、機械的な「どのように」に侵食されてしまう、ということがある。
それゆえ、概念的に凝集されたメカニズムを切り分けて別個の軽量なフレームワークにすること。

### 35. 隔離されたコア

モデル内にある複数の要素は、一部がコアドメインに仕え、一部が補助的な役割を果たすかもしれない。
こうした雑音ともつれによって、コアの発達が妨げられる。
それゆえ、モデルをリファクタリングして、コアの概念を補助的な役割を果たすものから分離すること。

### 36. 抽象化されたコア

別々のモジュールに置かれたサブドメインの間で大量の相互作用があると、モジュール間で多数の参照を生成する必要が生じて、分割したことの価値をほとんどなくしてしまう。
それゆえ、モデルにおける最も根本的な概念を識別し、それを別のクラス、抽象クラスまたはインタフェースに括り出すこと。
この抽象的なモデルは、重要なコンポーネント間の相互作用をほとんど表現するように設計すること。

巨大なシステムに包括的な原則がなく、そのせいで各要素を解釈する際に、設計全体にまたがるパターンにおいてどのような役割を果たすかという観点から考えることができなければ、開発者は「木を見て森を見ず」になってしまう。
「大規模な構造」は、システムをおおよその構造から議論し、理解できるようにするための言語である。
DDDは最後に、概念レベルの大規模な構造を扱うための5つのパターンを示す。

まず、大規模な構造を設計する際の基本的な考えを示す。

### 37. 進化する秩序

設計に制約がなければ、できあがるシステムの全体像が誰にも理解できない上に、保守するのも非常に困難になる。
しかし、アップフロントな設計上の想定によってプロジェクトを束縛し、設計から多くを奪ってしまうかもしれない。
それゆえ、概念上の大規模な構造をアプリケーションとともに進化させ、場合によっては途中でまったく別の構造に変更すること。
設計とモデルに関する詳細な意思決定を、制約しすぎてはならない。
ただし、大規模な構造を適用すべきなのは、モデルの開発に不自然な制約を強いることなく、システムを大幅に明確化する構造が見つけられたときのみである。

DDDにおける大規模な構造のパターンには、以下の3つがある。

### 38. システムのメタファ

ソフトウェアの設計は、非常に抽象的で把握しにくい傾向がある。
それゆえ、システムを表す具体的な類比があれば、それを大規模な構造として採用すること。
そのメタファを中心に設計を構成して、ユビキタス言語に取り入れること。
しかし、メタファはすべて不正確なものなので、拡大しすぎたり不適切であったりしないかを絶えず調べ直し、障害になるようなら取り消せるようにすること。

### 39. 責務のレイヤ

個々のオブジェクトがそれぞれ手作りの責務を与えられているとすると、ドメインの広い範囲をまとめて処理する上で指針も統一性も能力もないことになる。
それゆえ、ドメインに自然な階層が認められたら、それに幅広い抽象的な責務を割り当てること。
モデルをリファクタリングして、各ドメインオブジェクトと集約およびモジュールの責務が、1つのレイヤに与えられた責務の範囲にうまく収まるようにすること。

責務のレイヤの一例として、以下のようなものがある：

- 意思決定層
  - どんな戦略やポリシーを実行すべきかを決定する層
- ポリシー層
  - 戦略上のゴールや業務ルールを適用する層
- 業務層
  - ビジネス上の業務を表す層
- 潜在能力層
  - ビジネスのリソースを表す層

### 40. 知識レベル

エンティティ間にある役割と関係が状況によって変わるアプリケーションでは、複雑さが爆発的に増えかねない。
それゆえ、ソフトウェアを、アプリケーションの業務に関する業務レベルと、構造とふるまいに関する知識レベルに分けること。
知識レベルは、業務レベルのドメインモデルについての知識（ルールなど）を規定する。

深められて蒸留された非常に成熟したモデルにも、ブレイクスルーの機会は訪れる。

### 41. 着脱可能コンポーネントのフレームワーク

多様なアプリケーションの相互運用が必要で、すべてが同一の抽象に基づきながら独立して設計されている場合、複数の境界づけられたコンテキスト間で変換しなければならないために、統合が制限されてしまう。
それゆえ、インタフェースや相互作用にある抽象化されたコアを蒸留し、そのインタフェースの多様な実装を自由に置換できるようにするフレームワークを作成すること。

## 参考

- [Amazon.co.jp： エリック・エヴァンスのドメイン駆動設計 (IT Architects’Archive ソフトウェア開発の実践): エリック・エヴァンス, 今関 剛, 和智 右桂, 牧野 祐子: 本](http://www.amazon.co.jp/dp/4798121967)
- [[ 技術講座 ] Domain-Driven Designのエッセンス -目次-｜オブジェクトの広場](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/)
